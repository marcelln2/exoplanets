Old code sections / snippets that may or may not be useful in the future (Just for documentation)

Originally LINE 28, analyzing the % of missing data (and their importance)
    missing = pd.DataFrame({
        'Missing values' : df.isnull().sum(),
        'Missing data %' : df.isnull().sum() / len(df) * 100
    })

    #print(missing.sort_values(by='Missing data %', ascending=False))

    df = df.dropna(subset=['Planet_Name', 'Discovery_Time', 'Stellar_Temperature', 'Stellar_Mass', 'Stellar_Radius', \
                           'Orbital_Distance', 'Planet_Size', 'Planet_Mass', 'Density', 'Eccentricity'])
------
 Speed test on ITERROWS() VS ZIP

import timeit
a_time = timeit.timeit("""
for index, row in df.iterrows():
    _ = f"{row['Planet_Name']} | Size: {row['Planet_Size']:.2f}%"
""", globals=globals(), number=200)

b_time = timeit.timeit("""
for name, size in zip(df['Planet_Name'], df['Planet_Size']):
    _ = f"{name} | {size:.2f}%"
""", globals=globals(), number=200)

print(f"\nFirst Execution time: {a_time:.10f} seconds")
print(f"\nSecond Execution time: {b_time:.10f} seconds")
print(f"The second method is {a_time / b_time:.10f} times faster")

RESULT:
N = 10 : x 13
N = 100 : x 64
N = 200 : x 66.47
N = 1000 : x 67.75

------
New-old way of drawing 2 fancy lines. Useless information, useless lines.
df_HZ_CALC = df[df['Potentially_Habitable'] == True]
temps = np.linspace(df_HZ_CALC['Stellar_Temperature'].min(), df_HZ_CALC['Stellar_Temperature'].max(), len(df_HZ_CALC))
radii = df_HZ_CALC['Stellar_Radius'].median()
luminosities = 4 * np.pi * radii ** 2 * (temps / 5778) ** 4
hz_start = np.sqrt(luminosities / 1.1)
hz_end = np.sqrt(luminosities / 0.53)

plt.plot(hz_start, temps, linestyle='-', color='blue', label='Habitable Zone Start')
plt.plot(hz_end, temps, linestyle='-', color='orange', label='Habitable Zone End')

------
# Predicting values of Star Mass and Temp using Log-Log Linear Regression

df_LRM = df[['Stellar_Mass', 'Stellar_Temperature']].copy()
df_LRM['X'] = np.log10(df_LRM['Stellar_Mass'])
df_LRM['Y'] = np.log10(df_LRM['Stellar_Temperature'])

xM = df_LRM['X'].mean()
yM = df_LRM['Y'].mean()

df_LRM['X-XM'] = df_LRM['X'] - xM
df_LRM['Y-YM'] = df_LRM['Y'] - yM
df_LRM['X-XM*Y-XM'] = df_LRM['X-XM'] * df_LRM['Y-YM']
df_LRM['X-XM-SQRD'] = df_LRM['X-XM'] ** 2

a = df_LRM['X-XM*Y-XM'].sum() / df_LRM['X-XM-SQRD'].sum()  # 0.12785953885176093
b = yM - a * xM  # 3.7303772242936777

#  TEMPERATURE = 10^b * MASS^a
#  MASS = (TEMPERATURE / 10^b) ^ (1 / a)
#  RADIUS = (6.96 * 10^5 (6?)) * (MASS / (1.99 * 10^30)) ^ 0.8

df['Uncertain_Values'] = False
temp_na = df['Stellar_Temperature'].isna()
mass_na = df['Stellar_Mass'].isna()

df['Stellar_Temperature'] = df['Stellar_Temperature'].fillna((10 ** b) * (df['Stellar_Mass'] ** a))
df['Stellar_Mass'] = df['Stellar_Mass'].fillna((df['Stellar_Temperature'] / (10 ** b)) ** (1 / a))
df['Stellar_Radius'] = df['Stellar_Radius'].fillna(6.96 * 10 ** 5 * (df['Stellar_Mass'] / 1.99e30) ** 0.8)
------
plt.savefig('mice500.png') In order to save as a picture
------
If data point missing in a plot, do this:
plt.text(2019, 18.5, '1', ha='center', va='bottom')
------
# Trial with MICE -> Almost as bad as linreg, do NOT use!! (max_iter 100 vs 500 no diff!)

from sklearn.experimental import enable_iterative_imputer
from sklearn.impute import IterativeImputer

imputer = IterativeImputer(random_state = 100, max_iter = 500)
imputer.fit(df_knn)
df_mice_imputed = pd.DataFrame(imputer.transform(df_knn), columns=df_knn.columns)
df[['Stellar_Mass', 'Stellar_Temperature']] = df_mice_imputed[['Stellar_Mass', 'Stellar_Temperature']]
------
Heatmap. Useless, correlation values are obvious and are known.
plt.figure(figsize=[15, 15])
corr = df.corr(numeric_only=True)
sns.heatmap(
    corr,
    mask=(corr > -0.4) & (corr < 0.4), annot=True, cmap = 'Blues',
vmin = -1, vmax = 1)
plt.title("Correlations")
plt.show()
------
KMeans Clustering (AU vs Temp)

df = df[df['Potentially_Habitable'] == True]
from sklearn.cluster import KMeans
dataset = df[['Stellar_Temperature', 'Orbital_Distance']].values
km = KMeans(n_clusters=2, random_state=42).fit(dataset)
labels = km.labels_
df['Cluster_Label'] = labels

splot(df, 'Orbital_Distance', 'Stellar_Temperature', 'KMeans clustering',
      'Cluster_Label', 'AU', 'Kelvin', 'True, which = "both"')
